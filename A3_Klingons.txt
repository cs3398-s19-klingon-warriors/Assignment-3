CS 3398
Assignment 3
Team: Klingons

Team Members and Files:
1. Sarah Gibbons - SuperWorker.java
2. Talon Sjostrom - Robot.java
3. Rachel Kelmenson - Manager.java
4. Abel Shinabery - IWorkable.java, IFeedable.java
5. Serena Gutierrez - Worker.java

Explanations (per file):
==============================
SuperWorker.java
==============================
Adheres to open close principle: opened for extension, closed for modification. Note: we kept SuperWorker.java separate from Workers.java (by single responsibility), keeping them separate allows changes to one without risking changes to another. 

==============================
Iworkable.java, IFeedable.java
==============================
Adheres to the interface segregation principle.
<<<<<<< HEAD
By separating the original interface, IWorker, into two distinct interfaces, we allow
=======
By separating the original interface, IWorker, into two distinct interfaces (IWorkable and IFeedable), we allow
>>>>>>> 19cb4bc3cc881b0b0e5b785bc4d7cb5407ee6e91
only the necessary functions to be implemented. For instance, in the case of the Robot
class: Robots can work, but they cannot eat, so it was a waste of code to have them
implement an eat function when they would never use it. Worker and SuperWorker both work and eat, so they have the option to implement both IWorkable and IFeedable classes.

============
Worker.java
============
Adheres to open close & single responsibility.
By having the class separated from other worker types, we could extend it to add
more functionality which applies to the open close principle.
Furthermore, single responsibility applies as each class is organized by individual
responsibilities.

============
Robot.java
============
Adheres to Open Close & Single Responsibility principles.
The Robot class only uses one interface, not both like Worker and SuperWorker. Robot does share the same interface that Manager uses, but Robot does not carry the same responsibilities as Manager and should therefor be separated into its own class.


============
Manager.java
============
Manager is a distinct entity in the "workplace", with tasks and responsibilities separate from any other. It is not a worker, nor does it implement an interface (although you would think Managers have to eat!). For this reason, it makes sense to split Manager off into its own file. The Manager class is likely to be used or changed by users who may have nothing to do with the Worker classes, so keeping it separate aligns with the single responsibility principle. In future, users may want to make different types of managers - perhaps managers for different departments, or at different levels in the hierarchy. Open/close would recommend that those users extend the existing Manager class, rather than modify the class as it currently is. That may also be the case if different Managers need to have additional Workers or be able to issue more instructions. Since Manager is not an interface, the interface segregation principle doesn't apply to the class itself, but it does apply to the worker that this Manager manages. This Manager now uses an IWorkable worker, as opposed to the previous IWorker. The difference is that the old IWorker interface had methods to both work() and eat(), while IWorkable only does work(). Though Manager does not implement this interface, the Manager does not care if the worker eats; Manager only calls the work() method. In this case, separating the IWorker into two interfaces by the interface segregation principle helps focus the Manager's sphere of influence - in this form, the Manager would be unlikely (or perhaps unable) to overstep their bounds and tell the worker when to eat().



============
Additional Notes
============

Team discussion and planning was conducted daily on semi-private Slack channel and Trello board. We expect to integrate this more with the public Slack and ZenHub in the future!
